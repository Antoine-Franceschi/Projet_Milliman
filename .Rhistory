c=100
sigma = 5
p=4
simultheta = function(theta, t_max) {
simul = c(c/(1-theta))
bruit = rnorm(t_max, c, sigma^2)
for (i in (1:t_max)) {
X_i = theta*simul[i-1] + bruit[i]
simul = append(simul, X_i)
}
return(t(matrix(simul)))
}
N_simul = function(theta, t_max, N){
mat = matrix(0, ncol=t_max, nrow=N)
for (i in 1:N){
mat[i,] = simultheta(theta, t_max)
}
return(mat)
}
sums = function(Sample, theta, t_max){
n = (dim(Sample))[1]
for (i in 1:n){
Sample[i,]= cumsum(Sample[i,])
}
sum = matrix(0, ncol=1, nrow = t_max)
a = c/(1-theta)
b=0
for (j in (1:t_max)){
sum[j] = (mean(Sample[,j])-a)/sqrt(b)
a = theta*a + c
b= b+ sigma^2
}
sum[1]=0
return(sum)
}
graph_power = function(n){
theta = seq(from = 0, to = 1, by = 0.01)
pwr1 = c()
pwr2 = c()
for (thet in theta) {
simul = N_simul(thet, t_max, n)
Qps = Qp(simul, p)
sum = abs((sums(simul, thet, t_max)))
occ1 = length(Qps[Qps>qchisq(0.95,p)])/n
occ2 = length(sum[sum>qnorm(0.975)])/n
pwr1 = append(pwr1, occ1)
pwr2 = append(pwr2, occ2)
}
plot(theta, pwr1, col="red")
plot(theta, pwr2)
#abline(h=min(pwr), col="green")
#print(min(pwr))
}
graph_power(1000)
n=1000 #nombre de simulations
t_max=50
c=100
sigma = 5
p=2
simultheta = function(theta, t_max) {
simul = c(c/(1-theta))
bruit = rnorm(t_max, c, sigma^2)
for (i in (1:t_max)) {
X_i = theta*simul[i-1] + bruit[i]
simul = append(simul, X_i)
}
return(t(matrix(simul)))
}
N_simul = function(theta, t_max, N){
mat = matrix(0, ncol=t_max, nrow=N)
for (i in 1:N){
mat[i,] = simultheta(theta, t_max)
}
return(mat)
}
sums = function(Sample, theta, t_max){
n = (dim(Sample))[1]
for (i in 1:n){
Sample[i,]= cumsum(Sample[i,])
}
sum = matrix(0, ncol=1, nrow = t_max)
a = c/(1-theta)
b=0
for (j in (1:t_max)){
sum[j] = (mean(Sample[,j])-a)/sqrt(b)
a = theta*a + c
b= b+ sigma^2
}
sum[1]=0
return(sum)
}
graph_power = function(n){
theta = seq(from = 0, to = 1, by = 0.01)
pwr1 = c()
pwr2 = c()
for (thet in theta) {
simul = N_simul(thet, t_max, n)
Qps = Qp(simul, p)
sum = abs((sums(simul, thet, t_max)))
occ1 = length(Qps[Qps>qchisq(0.95,p)])/n
occ2 = length(sum[sum>qnorm(0.975)])/n
pwr1 = append(pwr1, occ1)
pwr2 = append(pwr2, occ2)
}
plot(theta, pwr1, col="red")
plot(theta, pwr2)
#abline(h=min(pwr), col="green")
#print(min(pwr))
}
graph_power(1000)
rm(list=ls()) # Removes all existing variables
Sample = read.table("Economic_Scenarios_1000_Simu.csv",sep=";",header=FALSE) # This command returns an object of the class data.frame
# For our purpose it is better to convert it into a matrix
n1 = dim(Sample)[1] # Number of rows
p1 = dim(Sample)[2] # Number of columns
X1_char = Sample[3:n1,7:p1]
tab_X_1 = as.matrix(X1_char)
#pour la premiere simulation
L=c()
for (i in 1:(floor(n1/4))){
L=append(L,4*i)
}
IMMO=tab_X_1[L,]
EQUITY= tab_X_1[(L-1),]
INFL=tab_X_1[L-2,]
VALN=tab_X_1[L-3,]
#on actualise les données
IMMO_act=IMMO*VALN
EQUITY_act = EQUITY*VALN
INFL_act = INFL*VALN
DtSt_IMMO=IMMO*VALN #on actualise les données
Dt_1St_1_IMMO=DtSt_IMMO[,1:(dim(DtSt_IMMO)[2]-1)]
Y_IMMO=DtSt_IMMO[,2:dim(DtSt_IMMO)[2]]-Dt_1St_1_IMMO
DtSt_EQUITY=EQUITY_act #on actualise les données
Dt_1St_1_EQUITY=DtSt_EQUITY[,1:(dim(DtSt_EQUITY)[2]-1)]
Y_EQUITY=DtSt_EQUITY[,2:dim(DtSt_EQUITY)[2]]-Dt_1St_1_EQUITY
DtSt_INFL=INFL*VALN #on actualise les données
Dt_1St_1_INFL=DtSt_INFL[,1:(dim(DtSt_INFL)[2]-1)]
Y_INFL=DtSt_INFL[,2:dim(DtSt_INFL)[2]]-Dt_1St_1_INFL
mean((IMMO_act[1,] - mean(IMMO_act[1,]))^2)
########################### Calcul de QP #########################
Qp= function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
Qp = c()
for (i in 1:n) {
Y_barre = mean(Sample[i,])
gamma_0 = mean((Sample[i,]-Y_barre)^2)
Qp_i = 0
for (j in 1:p){
gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]-Y_barre))
rho_j = gamma_j/gamma_0
Qp_i = Qp_i + d*(rho_j^2)
}
Qp = append(Qp, Qp_i)
}
return(Qp)
}
#print(Qp(IMMO_act,3))
########################### Calcul de QP* #########################
Qpstar = function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
Qpstar = c()
for (i in 1:n) {
Y_barre = mean(Sample[i,])
gamma_0 = mean((Sample[i,]-Y_barre)^2)
Qpstar_i = 0
for (j in 1:p){
gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]-Y_barre))
rho_j = gamma_j/gamma_0
tau_j = sum((Sample[i,(1+j):d]-Y_barre)^2*(Sample[i,1:(d-j)])^2) /(gamma_0^2)
Qpstar_i = Qpstar_i + d*(rho_j^2)
}
Qpstar = append(Qpstar, Qpstar_i)
}
return(Qpstar)
}
########################### Calcul de VRp #########################
VRP= function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
VRP = c()
for (i in 1:n) {
Y_barre = mean(Sample[i,])
gamma_0 = mean((Sample[i,]-Y_barre)^2)
VRP_i = 1
for (j in 1:(p-1)){
gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]))
rho_j = gamma_j/gamma_0
VRP_i = VRP_i + (1-(j/p))*rho_j
}
VRP = append(VRP, VRP_i)
}
return(VRP)
}
Graph = function(Sample,p){
Qp = Qpstar(Sample,p)
Y=c()
for(t in 1:length(Qp)){
p_value= 1-pchisq(Qp[t],df=p)
Y=append(Y,p_value)
}
#X=c(1:length(Qp))
#plot(X,Y)
#abline(h=min(Y), col="blue")
#abline(h=max(Y), col="blue")
#abline(h=mean(Y), col="red")
hist(Y,breaks=20,col="red",density=5,xlab="p-valeur",ylab="répartition",main=" Répartition des p_valeurs ",tck=0.01, freq = FALSE)
# breaks : nombre de barres
# density : barres vides (0) ou hachurées
# tck = 0.01 : longueur des graduations
# xlab & ylab : titre de l'axe des abscisses et ordonnées
# main : titre de l'histogramme
# col : couleur des barres - pour mettre d'autres couleurs
# Le paramètre freq = FALSE ou freq = F permet d'afficher la fréquence que représente chaque catégorie.
box() # encadre l'histogramme
densite <- density(Y) # estimer la densité que représente ces différentes valeurs
lines(densite, col = "blue",lwd=2) # Superposer une ligne de densité à l'histogramme
print(paste0(" min(p_valeur)  = ", min(Y)))
print(paste0(" max(p_valeur) = ",max(Y)))
print(paste0(" mean(p_valeur) ",mean(Y)))
print( "--------------")
for(alpha in c(0.1,0.05,0.01)){
print(paste0(" alpha = ",alpha))
print(paste0(" On rejette l'hypothèse nulle ,",length(Y[Y<=alpha])))
print( "--------------")
}
}
Graph(Y_IMMO,2)
p=4
VR_P=VRP(Y_IMMO,p)
X=c(1:length(VR_P))
print(paste0(" alpha = ",0.05))
a= 1-qnorm(0.975,mean=0,sd = 1)*sqrt(2*(p-1)/(p*length(VR_P)))
b= 1+qnorm(0.975,mean=0,sd = 1)*sqrt(2*(p-1)/(p*length(VR_P)))
#plot(X,VR_P)
hist(VR_P,breaks=20,col="red",density=6,xlab="Valeur de VR_P ",ylab="répartition",main=" Répartition des valeurs ",tck=0.02)
abline(v=a,col="blue")
abline(v=b,col="blue")
abline(v=mean(VR_P),col="green")
box()
mean(VR_P)
n=1000 #nombre de simulations
t_max=50
c=100
sigma = 5
p=4
simultheta = function(theta, t_max) {
simul = c(c/(1-theta))
bruit = rnorm(t_max, c, sigma^2)
for (i in (1:t_max)) {
X_i = theta*simul[i-1] + bruit[i]
simul = append(simul, X_i)
}
return(t(matrix(simul)))
}
N_simul = function(theta, t_max, N){
mat = matrix(0, ncol=t_max, nrow=N)
for (i in 1:N){
mat[i,] = simultheta(theta, t_max)
}
return(mat)
}
sums = function(Sample, theta, t_max){
n = (dim(Sample))[1]
for (i in 1:n){
Sample[i,]= cumsum(Sample[i,])
}
sum = matrix(0, ncol=1, nrow = t_max)
a = c/(1-theta)
b=0
for (j in (1:t_max)){
sum[j] = (mean(Sample[,j])-a)/sqrt(b)
a = theta*a + c
b= b+ sigma^2
}
sum[1]=0
return(sum)
}
graph_power = function(n){
theta = seq(from = 0, to = 1, by = 0.01)
pwr1 = c()
pwr2 = c()
for (thet in theta) {
simul = N_simul(thet, t_max, n)
Qps = Qp(simul, p)
sum = abs((sums(simul, thet, t_max)))
occ1 = length(Qps[Qps>qchisq(0.95,p)])/n
occ2 = length(sum[sum>qnorm(0.975)])/n
pwr1 = append(pwr1, occ1)
pwr2 = append(pwr2, occ2)
}
plot(theta, pwr1, col="red")
plot(theta, pwr2)
#abline(h=min(pwr), col="green")
#print(min(pwr))
}
graph_power(1000)
View(Y_EQUITY)
View(Y_EQUITY)
View(Y_IMMO)
View(Y_IMMO)
rm(list=ls()) # Removes all existing variables
Sample = read.table("Economic_Scenarios_1000_Simu.csv",sep=";",header=FALSE) # This command returns an object of the class data.frame
# For our purpose it is better to convert it into a matrix
n1 = dim(Sample)[1] # Number of rows
p1 = dim(Sample)[2] # Number of columns
X1_char = Sample[3:n1,7:p1]
tab_X_1 = as.matrix(X1_char)
#pour la premiere simulation
L=c()
for (i in 1:(floor(n1/4))){
L=append(L,4*i)
}
IMMO=tab_X_1[L,]
EQUITY= tab_X_1[(L-1),]
INFL=tab_X_1[L-2,]
VALN=tab_X_1[L-3,]
#on actualise les données
IMMO_act=IMMO*VALN
EQUITY_act = EQUITY*VALN
INFL_act = INFL*VALN
DtSt_IMMO=IMMO*VALN #on actualise les données
Dt_1St_1_IMMO=DtSt_IMMO[,1:(dim(DtSt_IMMO)[2]-1)]
Y_IMMO=DtSt_IMMO[,2:dim(DtSt_IMMO)[2]]-Dt_1St_1_IMMO
DtSt_EQUITY=EQUITY_act #on actualise les données
Dt_1St_1_EQUITY=DtSt_EQUITY[,1:(dim(DtSt_EQUITY)[2]-1)]
Y_EQUITY=DtSt_EQUITY[,2:dim(DtSt_EQUITY)[2]]-Dt_1St_1_EQUITY
DtSt_INFL=INFL*VALN #on actualise les données
Dt_1St_1_INFL=DtSt_INFL[,1:(dim(DtSt_INFL)[2]-1)]
Y_INFL=DtSt_INFL[,2:dim(DtSt_INFL)[2]]-Dt_1St_1_INFL
mean((IMMO_act[1,] - mean(IMMO_act[1,]))^2)
########################### Calcul de QP #########################
Qp= function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
Qp = c()
for (i in 1:n) {
Y_barre = mean(Sample[i,])
gamma_0 = mean((Sample[i,]-Y_barre)^2)
Qp_i = 0
for (j in 1:p){
gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]-Y_barre))
rho_j = gamma_j/gamma_0
Qp_i = Qp_i + d*(rho_j^2)
}
Qp = append(Qp, Qp_i)
}
return(Qp)
}
#print(Qp(IMMO_act,3))
########################### Calcul de QP* #########################
Qpstar = function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
Qpstar = c()
for (i in 1:n) {
Y_barre = mean(Sample[i,])
gamma_0 = mean((Sample[i,]-Y_barre)^2)
Qpstar_i = 0
for (j in 1:p){
gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]-Y_barre))
rho_j = gamma_j/gamma_0
tau_j = sum((Sample[i,(1+j):d]-Y_barre)^2*(Sample[i,1:(d-j)])^2) /(gamma_0^2)
Qpstar_i = Qpstar_i + d*(rho_j^2)
}
Qpstar = append(Qpstar, Qpstar_i)
}
return(Qpstar)
}
########################### Calcul de VRp #########################
VRP= function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
VRP = c()
for (i in 1:n) {
Y_barre = mean(Sample[i,])
gamma_0 = mean((Sample[i,]-Y_barre)^2)
VRP_i = 1
for (j in 1:(p-1)){
gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]))
rho_j = gamma_j/gamma_0
VRP_i = VRP_i + (1-(j/p))*rho_j
}
VRP = append(VRP, VRP_i)
}
return(VRP)
}
Graph = function(Sample,p){
Qp = Qpstar(Sample,p)
Y=c()
for(t in 1:length(Qp)){
p_value= 1-pchisq(Qp[t],df=p)
Y=append(Y,p_value)
}
#X=c(1:length(Qp))
#plot(X,Y)
#abline(h=min(Y), col="blue")
#abline(h=max(Y), col="blue")
#abline(h=mean(Y), col="red")
hist(Y,breaks=20,col="red",density=5,xlab="p-valeur",ylab="répartition",main=" Répartition des p_valeurs ",tck=0.01, freq = FALSE)
# breaks : nombre de barres
# density : barres vides (0) ou hachurées
# tck = 0.01 : longueur des graduations
# xlab & ylab : titre de l'axe des abscisses et ordonnées
# main : titre de l'histogramme
# col : couleur des barres - pour mettre d'autres couleurs
# Le paramètre freq = FALSE ou freq = F permet d'afficher la fréquence que représente chaque catégorie.
box() # encadre l'histogramme
densite <- density(Y) # estimer la densité que représente ces différentes valeurs
lines(densite, col = "blue",lwd=2) # Superposer une ligne de densité à l'histogramme
print(paste0(" min(p_valeur)  = ", min(Y)))
print(paste0(" max(p_valeur) = ",max(Y)))
print(paste0(" mean(p_valeur) ",mean(Y)))
print( "--------------")
for(alpha in c(0.1,0.05,0.01)){
print(paste0(" alpha = ",alpha))
print(paste0(" On rejette l'hypothèse nulle ,",length(Y[Y<=alpha])))
print( "--------------")
}
}
Graph(Y_IMMO,2)
p=4
VR_P=VRP(Y_IMMO,p)
X=c(1:length(VR_P))
print(paste0(" alpha = ",0.05))
a= 1-qnorm(0.975,mean=0,sd = 1)*sqrt(2*(p-1)/(p*length(VR_P)))
b= 1+qnorm(0.975,mean=0,sd = 1)*sqrt(2*(p-1)/(p*length(VR_P)))
#plot(X,VR_P)
hist(VR_P,breaks=20,col="red",density=6,xlab="Valeur de VR_P ",ylab="répartition",main=" Répartition des valeurs ",tck=0.02)
abline(v=a,col="blue")
abline(v=b,col="blue")
abline(v=mean(VR_P),col="green")
box()
mean(VR_P)
n=1000 #nombre de simulations
t_max=50
c=100
sigma = 5
p=4
simultheta = function(theta, t_max) {
simul = c(c/(1-theta))
bruit = rnorm(t_max, c, sigma^2)
for (i in (1:t_max)) {
X_i = theta*simul[i-1] + bruit[i]
simul = append(simul, X_i)
}
return(t(matrix(simul)))
}
N_simul = function(theta, t_max, N){
mat = matrix(0, ncol=t_max, nrow=N)
for (i in 1:N){
mat[i,] = simultheta(theta, t_max)
}
return(mat)
}
sums = function(Sample, theta, t_max){
n = (dim(Sample))[1]
for (i in 1:n){
Sample[i,]= cumsum(Sample[i,])
}
sum = matrix(0, ncol=1, nrow = t_max)
a = c/(1-theta)
b=0
for (j in (1:t_max)){
sum[j] = (mean(Sample[,j])-a)/sqrt(b)
a = theta*a + c
b= b+ sigma^2
}
sum[1]=0
return(sum)
}
graph_power = function(n){
theta = seq(from = 0, to = 1, by = 0.01)
pwr1 = c()
pwr2 = c()
for (thet in theta) {
simul = N_simul(thet, t_max, n)
Qps = Qp(simul, p)
sum = abs((sums(simul, thet, t_max)))
occ1 = length(Qps[Qps>qchisq(0.95,p)])/n
occ2 = length(sum[sum>qnorm(0.975)])/n
pwr1 = append(pwr1, occ1)
pwr2 = append(pwr2, occ2)
}
plot(theta, pwr1, col="red")
plot(theta, pwr2)
#abline(h=min(pwr), col="green")
#print(min(pwr))
}
graph_power(1000)
########################### Calcul de QP sur les colonnes #########################
Qpcol= function(Sample, p) {
n=dim(Sample)[1] #n =1000
d=dim(Sample)[2] # d = 50
t = d #valeur de t
Qp = c()
Y_barre_t = mean(Sample[,t])
gamma_0 = mean((Sample[,t]-Y_barre_t)^2)
Qp_j = 0
for (j in 1:p) {
Y_barre_tmoinsj = mean(Sample[,d-j])
gamma_j = mean((Sample[,t]-Y_barre_t)*(Sample[,(t-j)]-Y_barre_tmoinsj))
rho_j = gamma_j/gamma_0
Qp_j = Qp_j + n*(rho_j^2)
Qp = append(Qp, Qp_j)
}
return(Qp)
}
CRAN
install.packages("rmarkdown")
