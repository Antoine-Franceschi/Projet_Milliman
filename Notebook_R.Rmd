---
title: "R Notebook"
output: html_notebook
---

# Testing the Martingale hypothesis
Introduction: 

On se donne $\{ùëå_ùë° \}_{ùë°=‚àí‚àû}^{+‚àû}$ une s√©rie temporelle stationnaire et $ùêº_ùë°={ùëå_ùë°, ‚Ä¶,ùëå_0 }$ l‚Äôinformation disponible √† la date ùë°

# MDS
$ùëå_ùë°$ d√©finit une s√©quence de diff√©rences de martingales (MDS) si :

$$ ùîº[ùëå_ùë° |ùêº_{ùë°‚àí1} ]=0 $$
# MDH
Plus g√©n√©ralement on dit que $ùëå_ùë°$ satisfait l‚Äôhypoth√®se de diff√©rences de martingales (MDH)  si :
$$ ùîº[ùëå_ùë° |ùêº_{ùë°‚àí1} ]=ùúá‚àà‚Ñù~~~~~~~~~~~~~~(2)$$
Intuitivement cette hypoth√®se indique que le pr√©sent et le pass√© ne donnent pas plus d‚Äôinformation sur le futur que la moyenne du processus $ùíÄ_ùíï$ elle-m√™me ($ùîº[ùëå_ùë° ]=ùúá$). Autrement, dit que le meilleur pr√©dicteur du futur au sens des moindres carr√©s est $ùúá$.


La propri√©t√© fondamentale d√©coulant de la MDH est que $ùëå_ùë°$ est non pr√©dictible au sens des moindres carr√©s pour toute transformation lin√©aire ou non lin√©aire de l‚Äôinformation pass√©e $ùúî(ùêº_{ùë°‚àí1})$, i.e. de covariance nulle :
$$ ùîº[ùëå_ùë° |ùêº_{ùë°‚àí1} ]=ùúá‚àà‚Ñù‚Üîùîº[(ùëå_ùë°‚àíùúá)ùúî(ùêº_{ùë°‚àí1})]=0$$
En particulier, on note que toutes les autocorr√©lations (lag >0) de $ùëå_ùë°$ sont nulles. 

Rappelez-vous la d√©finition de mds dans l'√©quation (2) qui devrait tenir pour toute fonction w(). L'approche la plus simple consiste √† consid√©rer les fonctions lin√©aires w() ; telles que $ w(I_{t-1})= Y_{t-j}$ pour tout $j \geq 1$
Par cons√©quent, une condition n√©cessaire (mais pas suffisante, en g√©n√©ral) pour que la MDH tienne est que les s√©ries ne soient pas corr√©l√©es, c'est-√†-dire

$$ \gamma_j= Cov(Y_t,Y_{t-j})=ùîº[(ùëå_ùë°‚àíùúá)Y_{t-j}]=0~~~~~~~\forall j \geq1 $$

```{r}
rm(list=ls()) # Removes all existing variables

```



# parseur: 
```{r}
Sample = read.table("Economic_Scenarios_1000_Simu.csv",sep=";",header=FALSE) # This command returns an object of the class data.frame
 # For our purpose it is better to convert it into a matrix
n1 = dim(Sample)[1] # Number of rows
p1 = dim(Sample)[2] # Number of columns

X1_char = Sample[3:n1,7:p1] 
tab_X_1 = as.matrix(X1_char)
#n=dim(X1_char)[1] # Number of rows
#p=dim(X1_char)[2] # Number of columns


#pour la premiere simulation 

L=c()
for (i in 1:(floor(n1/4))){
  L=append(L,4*i)
}

IMMO=tab_X_1[L,]
EQUITY= tab_X_1[(L-1),]
INFL=tab_X_1[L-2,]
VALN=tab_X_1[L-3,]

```

#      I/ Test based on linear  measures of dependance
#        1/ Test based on a finite-dimensional conditioning set 

Supposons que nous observions des donn√©es brutes ${Y_t}_{t=1}^n $ alors $\hat{\gamma}_j$ est un estimateur consistant de $\gamma_j$: 

$$ \hat{\gamma}_j = (n-j)^{-1} \sum_{t=1+j}^{n}(Y_t-\bar{Y})(Y_{t-j}-\bar{Y})$$ 
$\bar{Y}$ est la moyenne de l'√©chantillon, on introduit aussi $\hat{\rho}_j$ le j eme ordre d'autocorr√©lation.


Premier test: 
$$ Q_p = n\sum_{j=1}^p \hat{\rho}_j^2~~~~~~~avec ~~~~~ \hat{\rho}_j=\frac{\hat{\gamma}_j}{\hat{\gamma}_0}$$
Deuxieme test: 

$$Q_p^* = n\sum_{j=1}^p \frac{\hat{\rho}_j^2}{\tau_j }$$
$$avec ~~~~~ \tau_j= \frac{1}{\hat{\gamma}_0^2}\sum_{j=1}^n (Y_t-\bar{Y})^2(Y_{t-j}-\bar{Y})^2 $$ 
Troisi√®me test - Variance Ratio: 

$$ VR_p= 1+2\sum_{j=1}^{p-1}(1-\frac{j}{p})\hat{\rho}_j $$



```{r}
 #on actualise les donn√©es 

IMMO_act=IMMO*VALN
EQUITY_act = EQUITY*VALN 
INFL_act = INFL*VALN

DtSt_IMMO=IMMO*VALN #on actualise les donn√©es 
Dt_1St_1_IMMO=DtSt_IMMO[,1:(dim(DtSt_IMMO)[2]-1)]
Y_IMMO=DtSt_IMMO[,2:dim(DtSt_IMMO)[2]]-Dt_1St_1_IMMO

DtSt_EQUITY=EQUITY_act #on actualise les donn√©es 
Dt_1St_1_EQUITY=DtSt_EQUITY[,1:(dim(DtSt_EQUITY)[2]-1)]
Y_EQUITY=DtSt_EQUITY[,2:dim(DtSt_EQUITY)[2]]-Dt_1St_1_EQUITY


DtSt_INFL=INFL*VALN #on actualise les donn√©es 
Dt_1St_1_INFL=DtSt_INFL[,1:(dim(DtSt_INFL)[2]-1)]
Y_INFL=DtSt_INFL[,2:dim(DtSt_INFL)[2]]-Dt_1St_1_INFL

Y_barre= mean(Y_INFL[1,])
mean((Y_INFL[1,(1+j):p]-Y_barre)*(Sample[1,1:(d-j)]))

```

```{r}
mean((IMMO_act[1,] - mean(IMMO_act[1,]))^2)
#print(IMMO_act[1,]-mean)
```


```{r}


########################### Calcul de QP #########################

Qp= function(Sample, p) {
  n=dim(Sample)[1] #n =1000
  d=dim(Sample)[2] # d = 50

  Qp = c()
  
  for (i in 1:n) {
    
    Y_barre = mean(Sample[i,])
    gamma_0 = mean((Sample[i,]-Y_barre)^2)
    Qp_i = 0
    
    for (j in 1:p){
      gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]-Y_barre))
      rho_j = gamma_j/gamma_0
      Qp_i = Qp_i + d*(rho_j^2)
    }
    Qp = append(Qp, Qp_i)
    
  }
  return(Qp)

}

#print(Qp(IMMO_act,3))


########################### Calcul de QP* #########################

Qpstar = function(Sample, p) {
  n=dim(Sample)[1] #n =1000
  d=dim(Sample)[2] # d = 50

  Qpstar = c()
  
  for (i in 1:n) {
    
    Y_barre = mean(Sample[i,])
    gamma_0 = mean((Sample[i,]-Y_barre)^2)
    Qpstar_i = 0
    
    for (j in 1:p){
      gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]-Y_barre))
      
      rho_j = gamma_j/gamma_0
      
      tau_j = sum((Sample[i,(1+j):d]-Y_barre)^2*(Sample[i,1:(d-j)])^2) /(gamm_0^2)
      Qpstar_i = Qp_i + d*(rho_j^2)
    }
    Qpstar = append(Qpstar, Qpstar_i)
  }
  return(Qpstar)

}

########################### Calcul de VRp #########################


VRP= function(Sample, p) {
  n=dim(Sample)[1] #n =1000
  d=dim(Sample)[2] # d = 50

  VRP = c()
  
  for (i in 1:n) {
    
    gamma_0 = mean((Sample[i,]-Y_barre)^2)
    
    VRP_i = 1
    
    for (j in 1:(p-1)){
      gamma_j = mean((Sample[i,(1+j):d]-Y_barre)*(Sample[i,1:(d-j)]))
      VRP_i = VRP_i + (1-(j/p))*rho_j
      }
    VRP = append(VRP, VRP_i)
    
  }
  return(VRP)

}
Qp(Y_IMMO,4)
```

Test statistique: 

on definit le degr√©e $\alpha$ 
l'hypoth√®se nulle est: $H_0 = \{Qp=0\}$ 
l'hypoth√®se alternantive est: $ H_1 = \{ |Q_p| \geq q_{chisq}(1-\alpha) \}$


```{r}
for (alpha in c(0.1,0.05,0.01)){
  quantile_Qp = qchisq(1-alpha,df=p)
  p_value= 1-pchisq(quantile_Qp,df=p)
  print(paste0(" alpha = ", alpha))
  print(paste0(" Qp = ",Qp))
  print(paste0(" Quantile = ",quantile_Qp))
  print(paste0(" p-valeur = ",p_value))
  print("  " )
}



```





#        2/ Test based on a infinite-dimensional conditioning set 

